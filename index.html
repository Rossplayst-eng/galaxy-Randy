<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Randy üíô</title>
  <style>
    html, body { height: 100%; margin: 0; background:#000; overflow:hidden; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .frame{ position:fixed; inset:0; display:grid; place-items:center; background:#000; }
    .stage{
      width:min(100vw, calc(100vh * 9/16));
      height:min(100vh, calc(100vw * 16/9));
      position:relative;
      overflow:hidden;
      border-radius:18px;
      background:#000;
    }
    canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; }
    .title{
      position:absolute; top:16px; left:50%; transform:translateX(-50%);
      z-index:5; pointer-events:none; user-select:none;
      color:#7ad7ff; font-weight:800; white-space:nowrap;
      font-size: clamp(28px, 6vw, 52px);
      text-shadow: 0 0 16px rgba(70,190,255,.95), 0 0 42px rgba(70,190,255,.35);
      display:flex; gap:10px; align-items:center;
    }
    .title span{ filter: drop-shadow(0 0 18px rgba(70,190,255,.95)); }
  </style>
</head>

<body>
  <div class="frame">
    <div class="stage" id="stage">
      <div class="title">Randy <span>üíô</span></div>
      <canvas id="c"></canvas>
    </div>
  </div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
  import { EffectComposer } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
  import { RenderPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
  import { UnrealBloomPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js";

  // ====== CONFIG ======
  const STICKER_PATH = "IMG_4079.png"; // <- tu sticker actual en el repo
  const PHRASES = ["Te amo","Mi desastre fav","Mi todo","Mi mundo","Mi universo"];

  // Velocidades (lento pero visible)
  const ORBIT_RPS = 1/20;     // 1 vuelta cada 20s (cambia a 1/30 si lo quieres m√°s lento)
  const BG_RPS    = 1/90;     // estrellas fondo (1 vuelta cada 90s)

  // Cantidades
  const WORD_COUNT    = 24;
  const STICKER_COUNT = 14;
  const SPARKLES      = 900;

  // Colores
  const BLUE = new THREE.Color("#46beff");
  const BLUE_SOFT = new THREE.Color("#c9f3ff");

  // ====== Setup ======
  const stage = document.getElementById("stage");
  const canvas = document.getElementById("c");

  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
  renderer.setClearColor(0x000000, 1);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.25;

  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 200);
  camera.position.set(0, 2.7, 11.0);

  // Luces
  scene.add(new THREE.AmbientLight(0xffffff, 0.55));
  const key = new THREE.DirectionalLight(0xffffff, 1.0);
  key.position.set(3, 5, 6);
  scene.add(key);

  // Post: Bloom (brillo difuminado REAL)
  const composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  composer.addPass(renderPass);

  const bloom = new UnrealBloomPass(new THREE.Vector2(1,1), 1.2, 0.55, 0.0);
  // strength, radius, threshold
  bloom.strength = 1.45;
  bloom.radius = 0.55;
  bloom.threshold = 0.0;
  composer.addPass(bloom);

  function resize(){
    const w = stage.clientWidth;
    const h = stage.clientHeight;
    renderer.setSize(w, h, false);
    composer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  addEventListener("resize", resize);
  resize();

  // Root (todo gira alrededor de Saturno)
  const root = new THREE.Group();
  scene.add(root);

  // ====== Fondo de estrellas esparcidas (rotan) ======
  const bg = new THREE.Group();
  root.add(bg);

  const bgGeo = new THREE.BufferGeometry();
  const BG_COUNT = 2200;
  const pos = new Float32Array(BG_COUNT * 3);
  for(let i=0;i<BG_COUNT;i++){
    const r = THREE.MathUtils.randFloat(28, 60);
    const th = THREE.MathUtils.randFloat(0, Math.PI*2);
    const u = THREE.MathUtils.randFloat(-1, 1);
    const ph = Math.acos(u);
    pos[i*3+0] = r * Math.sin(ph) * Math.cos(th);
    pos[i*3+1] = r * Math.cos(ph) * 0.55;
    pos[i*3+2] = r * Math.sin(ph) * Math.sin(th);
  }
  bgGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
  const bgMat = new THREE.PointsMaterial({ color:0xffffff, size:0.06, transparent:true, opacity:0.75, depthWrite:false });
  bg.add(new THREE.Points(bgGeo, bgMat));

  // ====== Saturno abajo ======
  const saturn = new THREE.Group();
  saturn.position.set(0, -1.55, 0);
  root.add(saturn);

  const planet = new THREE.Mesh(
    new THREE.SphereGeometry(1.45, 64, 64),
    new THREE.MeshStandardMaterial({
      color: new THREE.Color("#0b2a3d"),
      roughness: 0.45,
      metalness: 0.08,
      emissive: new THREE.Color("#08314a"),
      emissiveIntensity: 0.75
    })
  );
  saturn.add(planet);

  // Glow del planeta
  const glow = new THREE.Mesh(
    new THREE.SphereGeometry(1.62, 48, 48),
    new THREE.MeshBasicMaterial({
      color: BLUE,
      transparent:true,
      opacity: 0.28,
      blending: THREE.AdditiveBlending,
      depthWrite:false
    })
  );
  saturn.add(glow);

  // ====== Anillo ne√≥n (torus) ======
  const ring = new THREE.Group();
  ring.rotation.x = THREE.MathUtils.degToRad(68);
  saturn.add(ring);

  const R = 2.85;
  ring.add(new THREE.Mesh(
    new THREE.TorusGeometry(R, 0.10, 16, 260),
    new THREE.MeshBasicMaterial({ color: BLUE, transparent:true, opacity:0.70, blending: THREE.AdditiveBlending, depthWrite:false })
  ));
  ring.add(new THREE.Mesh(
    new THREE.TorusGeometry(R, 0.04, 12, 260),
    new THREE.MeshBasicMaterial({ color: BLUE_SOFT, transparent:true, opacity:0.85, blending: THREE.AdditiveBlending, depthWrite:false })
  ));

  // ====== Orbit group: ‚Äúcosas fijas‚Äù en el anillo ======
  // IMPORTANTE: aqu√≠ NO re-posicionamos cada frame, solo rotamos el grupo => se ven ‚Äúfijas‚Äù en el c√≠rculo
  const orbit = new THREE.Group();
  ring.add(orbit);

  // ---- Text sprites (gordito relleno + borde) ----
  function makeTextTexture(text){
    const c = document.createElement("canvas");
    const ctx = c.getContext("2d");
    c.width = 900; c.height = 220;

    ctx.clearRect(0,0,c.width,c.height);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // gordito
    ctx.font = "900 120px system-ui, -apple-system, Segoe UI, Roboto, Arial";

    // glow
    ctx.shadowColor = "rgba(70,190,255,0.95)";
    ctx.shadowBlur = 30;

    // fill
    ctx.fillStyle = "rgba(195,248,255,0.98)";
    ctx.fillText(text, c.width/2, c.height/2);

    // stroke
    ctx.shadowBlur = 0;
    ctx.lineWidth = 14;
    ctx.strokeStyle = "rgba(240,252,255,0.95)";
    ctx.strokeText(text, c.width/2, c.height/2);

    const tex = new THREE.CanvasTexture(c);
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.LinearFilter;
    return tex;
  }

  function makeTextSprite(text){
    const mat = new THREE.SpriteMaterial({
      map: makeTextTexture(text),
      transparent:true,
      depthWrite:false,
      blending: THREE.AdditiveBlending
    });
    const sp = new THREE.Sprite(mat);
    sp.scale.set(1.35, 0.40, 1);
    return sp;
  }

  // Colocamos palabras una vez alrededor del c√≠rculo
  const words = [];
  for(let i=0;i<WORD_COUNT;i++){
    const sp = makeTextSprite(PHRASES[i % PHRASES.length]);
    const a = (i/WORD_COUNT) * Math.PI*2;
    sp.position.set(Math.cos(a)*R*1.06, 0.22, Math.sin(a)*R*1.06);
    orbit.add(sp);
    words.push(sp);
  }

  // ---- Sticker sprite ----
  const loader = new THREE.TextureLoader();
  const stickerTex = await new Promise(resolve => {
    loader.load(STICKER_PATH, t => { t.colorSpace = THREE.SRGBColorSpace; resolve(t); }, undefined, () => resolve(null));
  });

  function makeStickerSprite(){
    if(!stickerTex){
      const sp = makeTextSprite("üíô");
      sp.scale.set(0.7, 0.7, 1);
      return sp;
    }
    const mat = new THREE.SpriteMaterial({ map: stickerTex, transparent:true, depthWrite:false });
    const sp = new THREE.Sprite(mat);
    sp.scale.set(0.82, 0.82, 1);
    return sp;
  }

  const stickers = [];
  for(let i=0;i<STICKER_COUNT;i++){
    const sp = makeStickerSprite();
    const a = (i/STICKER_COUNT) * Math.PI*2;
    const lane = 0.90 + 0.14*Math.sin(i*9.13);
    sp.position.set(Math.cos(a)*R*lane, -0.16, Math.sin(a)*R*lane);
    orbit.add(sp);
    stickers.push(sp);
  }

  // ---- Sparkles (puntos) ----
  const spGeo = new THREE.BufferGeometry();
  const spPos = new Float32Array(SPARKLES*3);
  const spSeed = new Float32Array(SPARKLES);
  for(let i=0;i<SPARKLES;i++){
    spSeed[i] = Math.random();
    const a = spSeed[i] * Math.PI*2;
    const lane = 0.90 + 0.26*Math.sin(spSeed[i]*50.0);
    spPos[i*3+0] = Math.cos(a)*R*lane;
    spPos[i*3+1] = (Math.sin(spSeed[i]*100.0)*0.06);
    spPos[i*3+2] = Math.sin(a)*R*lane;
  }
  spGeo.setAttribute("position", new THREE.BufferAttribute(spPos,3));
  spGeo.setAttribute("seed", new THREE.BufferAttribute(spSeed,1));

  const spMat = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.065,
    transparent:true,
    opacity: 0.95,
    depthWrite:false,
    blending: THREE.AdditiveBlending
  });
  const sparklePts = new THREE.Points(spGeo, spMat);
  orbit.add(sparklePts);

  // ====== Animaci√≥n ======
  const clock = new THREE.Clock();

  function animate(){
    const t = clock.getElapsedTime();

    // estrellas fondo rotan suave
    bg.rotation.y = t * (Math.PI*2*BG_RPS);

    // planeta vive
    planet.rotation.y = t * 0.12;
    ring.rotation.z = Math.sin(t*0.2) * 0.02;

    // Lo CLAVE: orbit rota => palabras ‚Äúfijas‚Äù en el c√≠rculo, girando lento alrededor
    orbit.rotation.y = t * (Math.PI*2*ORBIT_RPS);

    // Sparkles ‚Äúparpadean‚Äù un poco
    sparklePts.material.opacity = 0.80 + 0.18*Math.sin(t*2.2);

    composer.render();
    requestAnimationFrame(animate);
  }
  animate();
</script>
</body>
</html>
