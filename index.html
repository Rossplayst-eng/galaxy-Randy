<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Randy üíô</title>
  <style>
    html, body { height: 100%; margin: 0; background:#000; overflow:hidden; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }

    /* 9:16 stage centrado */
    .frame {
      position: fixed; inset: 0;
      display: grid; place-items: center;
      background: #000;
    }
    .stage {
      width: min(100vw, calc(100vh * 9/16));
      height: min(100vh, calc(100vw * 16/9));
      position: relative;
      overflow: hidden;
      border-radius: 18px;
      background: #000;
    }
    canvas { position:absolute; inset:0; width:100%; height:100%; display:block; }

    .title{
      position:absolute; top:16px; left:50%;
      transform:translateX(-50%);
      z-index:5;
      color:#7ad7ff;
      font-weight:800;
      font-size: clamp(28px, 6vw, 52px);
      letter-spacing: .2px;
      text-shadow: 0 0 16px rgba(70,190,255,.95), 0 0 40px rgba(70,190,255,.35);
      user-select:none;
      white-space:nowrap;
      display:flex; gap:10px; align-items:center;
      pointer-events:none;
    }
    .title span { filter: drop-shadow(0 0 16px rgba(70,190,255,.95)); }

    .hint{
      position:absolute; bottom:12px; left:50%;
      transform:translateX(-50%);
      z-index:6;
      color:rgba(255,255,255,.7);
      font-size:12px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(120,220,255,.18);
      background:rgba(0,0,0,.25);
      backdrop-filter: blur(8px);
      user-select:none;
      pointer-events:none;
    }
  </style>
</head>

<body>
  <div class="frame">
    <div class="stage" id="stage">
      <div class="title">Randy <span>üíô</span></div>
      <div class="hint">Toca para chispitas ‚ú®</div>
      <canvas id="c"></canvas>
    </div>
  </div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

  // ====== AJUSTES R√ÅPIDOS ======
  const STICKER_PATH = "IMG_4079.png";      // tu PNG al lado de index.html
  const PHRASES = ["Te amo","Mi desastre fav","Mi todo","Mi mundo","Mi universo"];

  const ORBIT_SPEED = 0.18;                // m√°s bajo = m√°s lento (prueba 0.12)
  const BG_ROT_SPEED = 0.03;               // estrellas de fondo rotando suave
  const RING_SPARKLES = 600;               // estrellitas girando con letras
  const WORD_COUNT = 26;                   // cu√°ntas palabras en el anillo
  const STICKER_COUNT = 16;                // cu√°ntos stickers orbitando

  // Paleta azul ne√≥n
  const BLUE = new THREE.Color("#46beff");
  const BLUE_SOFT = new THREE.Color("#bfefff");

  // ====== Setup ======
  const stage = document.getElementById("stage");
  const canvas = document.getElementById("c");

  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
  renderer.setClearColor(0x000000, 1);

  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 200);
  camera.position.set(0, 1.9, 7.6);

  // Luz suave + brillo
  scene.add(new THREE.AmbientLight(0xffffff, 0.55));
  const key = new THREE.DirectionalLight(0xffffff, 0.85);
  key.position.set(2, 4, 5);
  scene.add(key);

  function resize() {
    const w = stage.clientWidth;
    const h = stage.clientHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener("resize", resize);
  resize();

  // ====== Grupo central (todo gira alrededor de Saturno) ======
  const root = new THREE.Group();
  scene.add(root);

  // ====== Fondo de estrellas (esparcidas) ======
  const bgStarGeo = new THREE.BufferGeometry();
  const BG_COUNT = 2000;
  const pos = new Float32Array(BG_COUNT * 3);
  for (let i = 0; i < BG_COUNT; i++) {
    // esfera grande
    const r = THREE.MathUtils.randFloat(25, 55);
    const theta = THREE.MathUtils.randFloat(0, Math.PI * 2);
    const phi = Math.acos(THREE.MathUtils.randFloat(-1, 1));
    pos[i*3+0] = r * Math.sin(phi) * Math.cos(theta);
    pos[i*3+1] = r * Math.cos(phi) * 0.55;     // aplana un poquito
    pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
  }
  bgStarGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
  const bgStarMat = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.06,
    transparent: true,
    opacity: 0.75,
    depthWrite: false
  });
  const bgStars = new THREE.Points(bgStarGeo, bgStarMat);
  root.add(bgStars);

  // ====== Saturno (bola) ======
  const saturn = new THREE.Group();
  saturn.position.set(0, -1.35, 0);       // ‚Äúpiso‚Äù abajo
  root.add(saturn);

  const planetGeo = new THREE.SphereGeometry(1.35, 64, 64);
  const planetMat = new THREE.MeshStandardMaterial({
    color: new THREE.Color("#15324a"),
    roughness: 0.55,
    metalness: 0.05,
    emissive: new THREE.Color("#0b1d2b"),
    emissiveIntensity: 0.35
  });
  const planet = new THREE.Mesh(planetGeo, planetMat);
  saturn.add(planet);

  // brillo suave alrededor
  const glowGeo = new THREE.SphereGeometry(1.52, 48, 48);
  const glowMat = new THREE.MeshBasicMaterial({
    color: BLUE,
    transparent: true,
    opacity: 0.14,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  const planetGlow = new THREE.Mesh(glowGeo, glowMat);
  saturn.add(planetGlow);

  // ====== Anillo 3D ======
  const ring = new THREE.Group();
  ring.rotation.x = THREE.MathUtils.degToRad(68);   // inclinaci√≥n tipo saturno
  saturn.add(ring);

  // Base ring (tubo)
  const torusGeo = new THREE.TorusGeometry(2.65, 0.10, 16, 240);
  const torusMat = new THREE.MeshBasicMaterial({
    color: BLUE,
    transparent: true,
    opacity: 0.45,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  const torus = new THREE.Mesh(torusGeo, torusMat);
  ring.add(torus);

  // Ring highlight (m√°s fino y blanco-azul)
  const torusGeo2 = new THREE.TorusGeometry(2.65, 0.04, 12, 240);
  const torusMat2 = new THREE.MeshBasicMaterial({
    color: BLUE_SOFT,
    transparent: true,
    opacity: 0.55,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  const torus2 = new THREE.Mesh(torusGeo2, torusMat2);
  ring.add(torus2);

  // ====== Helpers: Sprites con texto ======
  function makeTextTexture(text) {
    const c = document.createElement("canvas");
    const ctx = c.getContext("2d");

    // tama√±o din√°mico
    c.width = 900;
    c.height = 220;

    ctx.clearRect(0,0,c.width,c.height);

    // ‚Äúgordita rellena‚Äù (sin depender de fuentes externas)
    ctx.font = "900 120px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // glow
    ctx.shadowColor = "rgba(70,190,255,0.95)";
    ctx.shadowBlur = 30;

    // fill
    ctx.fillStyle = "rgba(190,245,255,0.98)";
    ctx.fillText(text, c.width/2, c.height/2);

    // outline
    ctx.shadowBlur = 0;
    ctx.lineWidth = 14;
    ctx.strokeStyle = "rgba(235,250,255,0.95)";
    ctx.strokeText(text, c.width/2, c.height/2);

    const tex = new THREE.CanvasTexture(c);
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.LinearFilter;
    tex.needsUpdate = true;
    return tex;
  }

  function makeSpriteFromTexture(tex, scaleX=1.9, scaleY=0.48) {
    const mat = new THREE.SpriteMaterial({
      map: tex,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    const sp = new THREE.Sprite(mat);
    sp.scale.set(scaleX, scaleY, 1);
    return sp;
  }

  // ====== Sticker sprite ======
  const loader = new THREE.TextureLoader();
  const stickerTex = await new Promise((resolve) => {
    loader.load(
      STICKER_PATH,
      (t) => { t.colorSpace = THREE.SRGBColorSpace; resolve(t); },
      undefined,
      () => resolve(null)
    );
  });

  function makeStickerSprite() {
    if (!stickerTex) {
      // fallback si no existe el sticker
      const tex = makeTextTexture("üíô");
      return makeSpriteFromTexture(tex, 0.7, 0.7);
    }
    const mat = new THREE.SpriteMaterial({
      map: stickerTex,
      transparent: true,
      depthWrite: false
    });
    const sp = new THREE.Sprite(mat);
    sp.scale.set(0.85, 0.85, 1);
    return sp;
  }

  // ====== Orbit: grupo que rota sobre el anillo ======
  const orbit = new THREE.Group();
  ring.add(orbit);

  // Palabras pegadas al anillo (en el plano del anillo)
  const wordSprites = [];
  for (let i=0;i<WORD_COUNT;i++){
    const tex = makeTextTexture(PHRASES[i % PHRASES.length]);
    const sp = makeSpriteFromTexture(tex, 2.0, 0.55);
    orbit.add(sp);
    wordSprites.push(sp);
  }

  // Stickers (mismo sticker repetido)
  const stickerSprites = [];
  for (let i=0;i<STICKER_COUNT;i++){
    const sp = makeStickerSprite();
    orbit.add(sp);
    stickerSprites.push(sp);
  }

  // Sparkles (estrellitas girando con las letras)
  const sparkGeo = new THREE.BufferGeometry();
  const spPos = new Float32Array(RING_SPARKLES * 3);
  const spSeed = new Float32Array(RING_SPARKLES);
  for (let i=0;i<RING_SPARKLES;i++){
    spSeed[i] = Math.random();
    spPos[i*3+0] = 0;
    spPos[i*3+1] = 0;
    spPos[i*3+2] = 0;
  }
  sparkGeo.setAttribute("position", new THREE.BufferAttribute(spPos, 3));
  sparkGeo.setAttribute("seed", new THREE.BufferAttribute(spSeed, 1));

  const sparkMat = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.06,
    transparent: true,
    opacity: 0.85,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });
  const sparkles = new THREE.Points(sparkGeo, sparkMat);
  orbit.add(sparkles);

  // ====== Posicionar elementos alrededor del anillo ======
  function placeOrbitItems(t){
    const R = 2.65; // radio del torus
    // Palabras
    for (let i=0;i<wordSprites.length;i++){
      const a = (i/wordSprites.length) * Math.PI*2 + t*ORBIT_SPEED;
      const x = Math.cos(a) * (R * 1.03);
      const z = Math.sin(a) * (R * 1.03);
      wordSprites[i].position.set(x, 0.18, z);
      // profundidad (cuando ‚Äúviene hacia c√°mara‚Äù se hace un poquito m√°s grande)
      const depth = 0.78 + 0.32*(0.5 + 0.5*Math.sin(a));
      wordSprites[i].scale.set(2.0*depth, 0.55*depth, 1);
    }

    // Stickers
    for (let i=0;i<stickerSprites.length;i++){
      const a = (i/stickerSprites.length) * Math.PI*2 - t*ORBIT_SPEED*0.9;
      const lane = 0.92 + 0.12*Math.sin(i*9.13); // variedad suave
      const x = Math.cos(a) * (R * lane);
      const z = Math.sin(a) * (R * lane);
      const depth = 0.75 + 0.35*(0.5 + 0.5*Math.sin(a));
      stickerSprites[i].position.set(x, -0.15, z);
      stickerSprites[i].scale.set(0.85*depth, 0.85*depth, 1);
    }

    // Sparkles
    const positions = sparkGeo.attributes.position.array;
    const seeds = sparkGeo.attributes.seed.array;
    for (let i=0;i<RING_SPARKLES;i++){
      const base = seeds[i] * Math.PI*2;
      const speed = 0.7 + 1.4*seeds[i];
      const a = base + t*ORBIT_SPEED*speed;
      const lane = 0.90 + 0.28*Math.sin(seeds[i]*50.0);
      const x = Math.cos(a) * (R * lane);
      const z = Math.sin(a) * (R * lane);
      const y = (Math.sin(seeds[i]*100.0 + t*2.0) * 0.06);
      positions[i*3+0] = x;
      positions[i*3+1] = y;
      positions[i*3+2] = z;
    }
    sparkGeo.attributes.position.needsUpdate = true;
  }

  // ====== Toque: explosi√≥n de chispitas (pro, simple) ======
  const tapBurst = [];
  stage.addEventListener("pointerdown", (e)=>{
    const rect = stage.getBoundingClientRect();
    const nx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    const ny = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
    // crea 30 sparkles r√°pidos
    for (let i=0;i<30;i++){
      tapBurst.push({
        a: Math.random()*Math.PI*2,
        r: 1.8 + Math.random()*1.4,
        t: 0,
        life: 0.6 + Math.random()*0.6,
        nx, ny
      });
    }
  });

  function drawTapBurst(dt){
    // (solo a√±ade un poquito m√°s de brillo al ring por un momento)
    if (tapBurst.length === 0) return;
    torusMat.opacity = Math.min(0.75, torusMat.opacity + 0.010);
    torusMat2.opacity = Math.min(0.85, torusMat2.opacity + 0.012);

    for (let i=tapBurst.length-1; i>=0; i--){
      tapBurst[i].t += dt;
      if (tapBurst[i].t >= tapBurst[i].life) tapBurst.splice(i,1);
    }
  }

  // ====== Animaci√≥n ======
  const clock = new THREE.Clock();

  function animate(){
    const dt = clock.getDelta();
    const t = clock.elapsedTime;

    // todo rota alrededor de Saturno lentamente
    bgStars.rotation.y = t * BG_ROT_SPEED;

    // leve movimiento del planeta (vida)
    planet.rotation.y = t * 0.12;
    planet.rotation.x = Math.sin(t*0.3) * 0.02;

    // el anillo vibra muy poquito
    ring.rotation.z = Math.sin(t*0.2) * 0.02;

    // elementos orbitando pegados al anillo
    placeOrbitItems(t);

    // tap burst
    drawTapBurst(dt);

    // vuelve opacidad a normal suavemente
    torusMat.opacity += (0.45 - torusMat.opacity) * 0.04;
    torusMat2.opacity += (0.55 - torusMat2.opacity) * 0.04;

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  animate();
</script>
</body>
</html>
